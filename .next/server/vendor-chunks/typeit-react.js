"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typeit-react";
exports.ids = ["vendor-chunks/typeit-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/typeit-react/dist/index.es.js":
/*!****************************************************!*\
  !*** ./node_modules/typeit-react/dist/index.es.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypeIt)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _empty, empty_fn, _fire, fire_fn, _move, move_fn, _prepLoop, prepLoop_fn, _fireItemWithContext, fireItemWithContext_fn, _wait, wait_fn, _attachCursor, attachCursor_fn, _elementIsInput, elementIsInput_fn, _queueAndReturn, queueAndReturn_fn, _maybeAppendPause, maybeAppendPause_fn, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn, _updateOptions, updateOptions_fn, _generateQueue, generateQueue_fn, _buildOptions, _prependHardcodedStrings, prependHardcodedStrings_fn, _setUpCursor, setUpCursor_fn, _addSplitPause, addSplitPause_fn, _type, type_fn, _delete, delete_fn, _removeNode, removeNode_fn, _getPace, getPace_fn, _derivedCursorPosition, derivedCursorPosition_get, _isInput, isInput_get, _shouldRenderCursor, shouldRenderCursor_get, _allChars, allChars_get, _a;\n\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => isArray(value) ? value : [value];\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      var _a2;\n      return _q.set(Symbol((_a2 = step.char) == null ? void 0 : _a2.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    done,\n    reset,\n    destroy,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nconst createElement = (el) => document.createElement(el);\nconst createTextNode = (content) => document.createTextNode(content);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst toArray = (val) => Array.from(val);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      var _a2, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a2 = node.classList) == null ? void 0 : _a2.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst isNumber = (value) => Number.isInteger(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element == null ? void 0 : element.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => {\n  var _a2;\n  return (_a2 = queueItem.func) == null ? void 0 : _a2.call(null);\n};\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => {\n  return \"value\" in el;\n};\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : (\n    // If we add one-off fresh elements, there will be no\n    // \"originalParent\", so always fall back to the default target.\n    character.originalParent || originalTarget\n  );\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nlet processCursorOptions = (cursorOptions) => {\n  var _a2, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a2 = cursorOptions.animation) == null ? void 0 : _a2.frames) || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? (\n    // This parent still needs to exist.\n    node\n  ) : (\n    // There's nothing else in there, so just delete the entire thing.\n    // By doing this, we clean up markup as we go along.\n    nodeParent\n  );\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nfunction splitOnBreak(str) {\n  return str.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n}\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet TypeIt$1 = (_a = class {\n  constructor(element, options = {}) {\n    __privateAdd(this, _empty);\n    /**\n     * Execute items in the queue.\n     *\n     * @param remember If false, each queue item will be destroyed once executed.\n     * @returns\n     */\n    __privateAdd(this, _fire);\n    __privateAdd(this, _move);\n    /**\n     * 1. Reset queue.\n     * 2. Reset initial pause.\n     */\n    __privateAdd(this, _prepLoop);\n    __privateAdd(this, _fireItemWithContext);\n    __privateAdd(this, _wait);\n    /**\n     * Attach it to the DOM so, along with the required CSS transition.\n     */\n    __privateAdd(this, _attachCursor);\n    __privateAdd(this, _elementIsInput);\n    __privateAdd(this, _queueAndReturn);\n    __privateAdd(this, _maybeAppendPause);\n    __privateAdd(this, _generateTemporaryOptionQueueItems);\n    __privateAdd(this, _updateOptions);\n    /**\n     * Based on provided strings, generate a TypeIt queue\n     * to be fired for each character in the string.\n     */\n    __privateAdd(this, _generateQueue);\n    __privateAdd(this, _prependHardcodedStrings);\n    /**\n     * Provided it's a non-form element and the options is provided,\n     * set up the cursor element for the animation.\n     */\n    __privateAdd(this, _setUpCursor);\n    __privateAdd(this, _addSplitPause);\n    __privateAdd(this, _type);\n    __privateAdd(this, _delete);\n    __privateAdd(this, _removeNode);\n    __privateAdd(this, _getPace);\n    __privateAdd(this, _derivedCursorPosition);\n    __privateAdd(this, _isInput);\n    __privateAdd(this, _shouldRenderCursor);\n    __privateAdd(this, _allChars);\n    __publicField(this, \"element\");\n    __publicField(this, \"timeouts\");\n    __publicField(this, \"cursorPosition\");\n    __publicField(this, \"predictedCursorPosition\");\n    __publicField(this, \"statuses\", {\n      started: false,\n      completed: false,\n      frozen: false,\n      destroyed: false\n    });\n    __publicField(this, \"opts\");\n    __publicField(this, \"id\");\n    __publicField(this, \"queue\");\n    __publicField(this, \"cursor\");\n    __publicField(this, \"unfreeze\", () => {\n    });\n    __publicField(this, \"is\", function(key) {\n      return this.statuses[key];\n    });\n    __privateAdd(this, _buildOptions, (options) => {\n      options.cursor = processCursorOptions(\n        options.cursor ?? DEFAULT_OPTIONS.cursor\n      );\n      this.opts.strings = __privateMethod(this, _prependHardcodedStrings, prependHardcodedStrings_fn).call(this, asArray(this.opts.strings));\n      this.opts = merge(this.opts, {\n        html: !__privateGet(this, _isInput, isInput_get) && this.opts.html,\n        nextStringDelay: calculateDelay(this.opts.nextStringDelay),\n        loopDelay: calculateDelay(this.opts.loopDelay)\n      });\n    });\n    this.opts = merge(DEFAULT_OPTIONS, options);\n    this.element = selectorToElement(element);\n    this.timeouts = [];\n    this.cursorPosition = 0;\n    this.unfreeze = () => {\n    };\n    this.predictedCursorPosition = null;\n    this.statuses = merge({}, DEFAULT_STATUSES);\n    this.id = generateHash();\n    this.queue = Queue([{ delay: this.opts.startDelay }]);\n    __privateGet(this, _buildOptions).call(this, options);\n    this.cursor = __privateMethod(this, _setUpCursor, setUpCursor_fn).call(this);\n    this.element.dataset.typeitId = this.id;\n    appendStyleBlock(PLACEHOLDER_CSS);\n    if (this.opts.strings.length) {\n      __privateMethod(this, _generateQueue, generateQueue_fn).call(this);\n    }\n  }\n  /**\n   * Can only be called once.\n   */\n  go() {\n    if (this.statuses.started) {\n      return this;\n    }\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    if (!this.opts.waitUntilVisible) {\n      __privateMethod(this, _fire, fire_fn).call(this);\n      return this;\n    }\n    fireWhenVisible(this.element, __privateMethod(this, _fire, fire_fn).bind(this));\n    return this;\n  }\n  destroy(shouldRemoveCursor = true) {\n    this.timeouts = destroyTimeouts(this.timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && this.cursor && __privateMethod(this, _removeNode, removeNode_fn).call(this, this.cursor);\n    this.statuses.destroyed = true;\n  }\n  reset(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      this.queue.wipe();\n      rebuild(this);\n    } else {\n      this.queue.reset();\n    }\n    this.cursorPosition = 0;\n    for (let property in this.statuses) {\n      this.statuses[property] = false;\n    }\n    this.element[__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  }\n  type(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let chars = maybeChunkStringAsHtml(string, this.opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => __privateMethod(this, _type, type_fn).call(this, char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await this.opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await this.opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, itemsToQueue, actionOpts);\n  }\n  break(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {\n      func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  }\n  move(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: this.queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get)\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    this.predictedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get) + numberOfSteps;\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: () => __privateMethod(this, _move, move_fn).call(this, directionalStep),\n          delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this),\n          cursorable: true\n        },\n        Math.abs(numberOfSteps)\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  exec(func, actionOpts = {}) {\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]], actionOpts);\n  }\n  options(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    __privateMethod(this, _updateOptions, updateOptions_fn).call(this, opts);\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, {}, actionOpts);\n  }\n  pause(milliseconds, actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, { delay: handleFunctionalArg(milliseconds) }, actionOpts);\n  }\n  delete(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = __privateMethod(this, _generateTemporaryOptionQueueItems, generateTemporaryOptionQueueItems_fn).call(this, actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = this.queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get),\n        to\n      });\n    })();\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, [\n      bookEndQueueItems[0],\n      ...duplicate(\n        {\n          func: __privateMethod(this, _delete, delete_fn).bind(this),\n          delay: instant ? 0 : __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n          deletable: true\n        },\n        rounds\n      ),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  }\n  freeze() {\n    this.statuses.frozen = true;\n  }\n  /**\n   * Like `.go()`, but more... \"off the grid.\"\n   *\n   * - won't trigger `afterComplete` callback\n   * - items won't be replayed after `.reset()`\n   *\n   * When called, all non-done items will be \"flushed\" --\n   * that is, executed, but not remembered.\n   */\n  flush(cb = () => {\n  }) {\n    __privateMethod(this, _attachCursor, attachCursor_fn).call(this);\n    __privateMethod(this, _fire, fire_fn).call(this, false).then(cb);\n    return this;\n  }\n  getQueue() {\n    return this.queue;\n  }\n  getOptions() {\n    return this.opts;\n  }\n  updateOptions(options) {\n    return __privateMethod(this, _updateOptions, updateOptions_fn).call(this, options);\n  }\n  getElement() {\n    return this.element;\n  }\n  empty(actionOpts = {}) {\n    return __privateMethod(this, _queueAndReturn, queueAndReturn_fn).call(this, { func: __privateMethod(this, _empty, empty_fn).bind(this) }, actionOpts);\n  }\n}, _empty = new WeakSet(), empty_fn = async function() {\n  if (__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this)) {\n    this.element.value = \"\";\n    return;\n  }\n  __privateGet(this, _allChars, allChars_get).forEach(__privateMethod(this, _removeNode, removeNode_fn).bind(this));\n  return;\n}, _fire = new WeakSet(), fire_fn = async function(remember = true) {\n  this.statuses.started = true;\n  let cleanUp = (qKey) => {\n    this.queue.done(qKey, !remember);\n  };\n  try {\n    let queueItems = [...this.queue.getQueue()];\n    for (let index = 0; index < queueItems.length; index++) {\n      let [queueKey, queueItem] = queueItems[index];\n      if (queueItem.done)\n        continue;\n      if (!queueItem.deletable || queueItem.deletable && __privateGet(this, _allChars, allChars_get).length) {\n        let newIndex = await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n        Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n          let [key] = queueItems[i];\n          cleanUp(key);\n        });\n        index = newIndex;\n      }\n      cleanUp(queueKey);\n    }\n    if (!remember) {\n      return this;\n    }\n    this.statuses.completed = true;\n    await this.opts.afterComplete(this);\n    if (!this.opts.loop) {\n      throw \"\";\n    }\n    let delay = this.opts.loopDelay;\n    __privateMethod(this, _wait, wait_fn).call(this, async () => {\n      await __privateMethod(this, _prepLoop, prepLoop_fn).call(this, delay[0]);\n      __privateMethod(this, _fire, fire_fn).call(this);\n    }, delay[1]);\n  } catch (e) {\n  }\n  return this;\n}, _move = new WeakSet(), move_fn = async function(step) {\n  this.cursorPosition = updateCursorPosition(\n    step,\n    this.cursorPosition,\n    __privateGet(this, _allChars, allChars_get)\n  );\n  repositionCursor(this.element, __privateGet(this, _allChars, allChars_get), this.cursorPosition);\n}, _prepLoop = new WeakSet(), prepLoop_fn = async function(delay) {\n  let derivedCursorPosition = __privateGet(this, _derivedCursorPosition, derivedCursorPosition_get);\n  derivedCursorPosition && await __privateMethod(this, _move, move_fn).call(this, { value: derivedCursorPosition });\n  let queueItems = __privateGet(this, _allChars, allChars_get).map((c) => {\n    return [\n      Symbol(),\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n        deletable: true,\n        shouldPauseCursor: () => true\n      }\n    ];\n  });\n  for (let index = 0; index < queueItems.length; index++) {\n    await __privateMethod(this, _fireItemWithContext, fireItemWithContext_fn).call(this, index, queueItems);\n  }\n  this.queue.reset();\n  this.queue.set(0, { delay });\n}, _fireItemWithContext = new WeakSet(), fireItemWithContext_fn = function(index, queueItems) {\n  return fireItem({\n    index,\n    queueItems,\n    wait: __privateMethod(this, _wait, wait_fn).bind(this),\n    cursor: this.cursor,\n    cursorOptions: this.opts.cursor\n  });\n}, _wait = new WeakSet(), wait_fn = async function(callback, delay, silent = false) {\n  if (this.statuses.frozen) {\n    await new Promise((resolve) => {\n      this.unfreeze = () => {\n        this.statuses.frozen = false;\n        resolve();\n      };\n    });\n  }\n  silent || await this.opts.beforeStep(this);\n  await wait(callback, delay, this.timeouts);\n  silent || await this.opts.afterStep(this);\n}, _attachCursor = new WeakSet(), attachCursor_fn = async function() {\n  !__privateMethod(this, _elementIsInput, elementIsInput_fn).call(this) && this.cursor && this.element.appendChild(this.cursor);\n  if (__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    setCursorStyles(this.id, this.element);\n    this.cursor.dataset.tiAnimationId = this.id;\n    let { animation } = this.opts.cursor;\n    let { frames, options } = animation;\n    setCursorAnimation({\n      frames,\n      cursor: this.cursor,\n      options: {\n        duration: this.opts.cursorSpeed,\n        ...options\n      }\n    });\n  }\n}, _elementIsInput = new WeakSet(), elementIsInput_fn = function() {\n  return isInput(this.element);\n}, _queueAndReturn = new WeakSet(), queueAndReturn_fn = function(steps, opts) {\n  this.queue.add(steps);\n  __privateMethod(this, _maybeAppendPause, maybeAppendPause_fn).call(this, opts);\n  return this;\n}, _maybeAppendPause = new WeakSet(), maybeAppendPause_fn = function(opts = {}) {\n  let delay = opts.delay;\n  delay && this.queue.add({ delay });\n}, _generateTemporaryOptionQueueItems = new WeakSet(), generateTemporaryOptionQueueItems_fn = function(newOptions = {}) {\n  return [\n    { func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, newOptions) },\n    { func: () => __privateMethod(this, _updateOptions, updateOptions_fn).call(this, this.opts) }\n  ];\n}, _updateOptions = new WeakSet(), updateOptions_fn = async function(opts) {\n  this.opts = merge(this.opts, opts);\n}, _generateQueue = new WeakSet(), generateQueue_fn = function() {\n  let strings = this.opts.strings.filter((string) => !!string);\n  strings.forEach((string, index) => {\n    this.type(string);\n    if (index + 1 === strings.length) {\n      return;\n    }\n    let splitItems = this.opts.breakLines ? [{ func: () => __privateMethod(this, _type, type_fn).call(this, createElement(\"BR\")), typeable: true }] : duplicate(\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1)\n      },\n      this.queue.getTypeable().length\n    );\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, splitItems);\n  });\n}, _buildOptions = new WeakMap(), _prependHardcodedStrings = new WeakSet(), prependHardcodedStrings_fn = function(strings) {\n  let existingMarkup = this.element.innerHTML;\n  if (!existingMarkup) {\n    return strings;\n  }\n  this.element.innerHTML = \"\";\n  if (this.opts.startDelete) {\n    this.element.innerHTML = existingMarkup;\n    expandTextNodes(this.element);\n    __privateMethod(this, _addSplitPause, addSplitPause_fn).call(this, duplicate(\n      {\n        func: __privateMethod(this, _delete, delete_fn).bind(this),\n        delay: __privateMethod(this, _getPace, getPace_fn).call(this, 1),\n        deletable: true\n      },\n      __privateGet(this, _allChars, allChars_get).length\n    ));\n    return strings;\n  }\n  return splitOnBreak(existingMarkup).concat(strings);\n}, _setUpCursor = new WeakSet(), setUpCursor_fn = function() {\n  if (__privateGet(this, _isInput, isInput_get)) {\n    return null;\n  }\n  let cursor = createElement(\"span\");\n  cursor.className = CURSOR_CLASS;\n  if (!__privateGet(this, _shouldRenderCursor, shouldRenderCursor_get)) {\n    cursor.style.visibility = \"hidden\";\n    return cursor;\n  }\n  cursor.innerHTML = getParsedBody(this.opts.cursorChar).innerHTML;\n  return cursor;\n}, _addSplitPause = new WeakSet(), addSplitPause_fn = function(items) {\n  let delay = this.opts.nextStringDelay;\n  this.queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n}, _type = new WeakSet(), type_fn = function(char) {\n  insertIntoElement(this.element, char);\n}, _delete = new WeakSet(), delete_fn = function() {\n  if (!__privateGet(this, _allChars, allChars_get).length)\n    return;\n  if (__privateGet(this, _isInput, isInput_get)) {\n    this.element.value = this.element.value.slice(0, -1);\n  } else {\n    __privateMethod(this, _removeNode, removeNode_fn).call(this, __privateGet(this, _allChars, allChars_get)[this.cursorPosition]);\n  }\n}, _removeNode = new WeakSet(), removeNode_fn = function(node) {\n  removeNode(node, this.element);\n}, _getPace = new WeakSet(), getPace_fn = function(index = 0) {\n  return calculatePace(this.opts)[index];\n}, _derivedCursorPosition = new WeakSet(), derivedCursorPosition_get = function() {\n  return this.predictedCursorPosition ?? this.cursorPosition;\n}, _isInput = new WeakSet(), isInput_get = function() {\n  return isInput(this.element);\n}, _shouldRenderCursor = new WeakSet(), shouldRenderCursor_get = function() {\n  return !!this.opts.cursor && !__privateGet(this, _isInput, isInput_get);\n}, _allChars = new WeakSet(), allChars_get = function() {\n  return getAllChars(this.element);\n}, _a);\nconst DynamicElementComponent = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const { as: As } = props;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(As, { ref, ...props });\n});\nconst defaultPropOptions = {};\nconst TypeIt = ({\n  as = \"span\",\n  options = defaultPropOptions,\n  children = null,\n  getBeforeInit = (instance) => instance,\n  getAfterInit = (instance) => instance,\n  ...remainingProps\n}) => {\n  const elementRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const instanceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [shouldShowChildren, setShouldShowChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n  const [instanceOptions, setInstanceOptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _a2;\n    if (!instanceOptions)\n      return;\n    ((_a2 = instanceRef.current) == null ? void 0 : _a2.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => {\n      var _a2;\n      return (_a2 = instanceRef.current) == null ? void 0 : _a2.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\n    DynamicElementComponent,\n    {\n      ref: elementRef,\n      as,\n      children: shouldShowChildren ? children : null,\n      style: { opacity: shouldShowChildren ? 0 : 1 },\n      ...remainingProps\n    }\n  );\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZWl0LXJlYWN0L2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxTQUFTO0FBQzFHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsVUFBVSxjQUFjLHVCQUF1QixVQUFVLG9CQUFvQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7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cUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1uZXh0Ly4vbm9kZV9tb2R1bGVzL3R5cGVpdC1yZWFjdC9kaXN0L2luZGV4LmVzLmpzPzE5YTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG52YXIgX2VtcHR5LCBlbXB0eV9mbiwgX2ZpcmUsIGZpcmVfZm4sIF9tb3ZlLCBtb3ZlX2ZuLCBfcHJlcExvb3AsIHByZXBMb29wX2ZuLCBfZmlyZUl0ZW1XaXRoQ29udGV4dCwgZmlyZUl0ZW1XaXRoQ29udGV4dF9mbiwgX3dhaXQsIHdhaXRfZm4sIF9hdHRhY2hDdXJzb3IsIGF0dGFjaEN1cnNvcl9mbiwgX2VsZW1lbnRJc0lucHV0LCBlbGVtZW50SXNJbnB1dF9mbiwgX3F1ZXVlQW5kUmV0dXJuLCBxdWV1ZUFuZFJldHVybl9mbiwgX21heWJlQXBwZW5kUGF1c2UsIG1heWJlQXBwZW5kUGF1c2VfZm4sIF9nZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXMsIGdlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtc19mbiwgX3VwZGF0ZU9wdGlvbnMsIHVwZGF0ZU9wdGlvbnNfZm4sIF9nZW5lcmF0ZVF1ZXVlLCBnZW5lcmF0ZVF1ZXVlX2ZuLCBfYnVpbGRPcHRpb25zLCBfcHJlcGVuZEhhcmRjb2RlZFN0cmluZ3MsIHByZXBlbmRIYXJkY29kZWRTdHJpbmdzX2ZuLCBfc2V0VXBDdXJzb3IsIHNldFVwQ3Vyc29yX2ZuLCBfYWRkU3BsaXRQYXVzZSwgYWRkU3BsaXRQYXVzZV9mbiwgX3R5cGUsIHR5cGVfZm4sIF9kZWxldGUsIGRlbGV0ZV9mbiwgX3JlbW92ZU5vZGUsIHJlbW92ZU5vZGVfZm4sIF9nZXRQYWNlLCBnZXRQYWNlX2ZuLCBfZGVyaXZlZEN1cnNvclBvc2l0aW9uLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0LCBfaXNJbnB1dCwgaXNJbnB1dF9nZXQsIF9zaG91bGRSZW5kZXJDdXJzb3IsIHNob3VsZFJlbmRlckN1cnNvcl9nZXQsIF9hbGxDaGFycywgYWxsQ2hhcnNfZ2V0LCBfYTtcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGlzQXJyYXkgPSAodGhpbmcpID0+IEFycmF5LmlzQXJyYXkodGhpbmcpO1xuY29uc3QgYXNBcnJheSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5sZXQgUXVldWUgPSBmdW5jdGlvbihpbml0aWFsSXRlbXMpIHtcbiAgbGV0IGFkZCA9IGZ1bmN0aW9uKHN0ZXBzKSB7XG4gICAgYXNBcnJheShzdGVwcykuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiBfcS5zZXQoU3ltYm9sKChfYTIgPSBzdGVwLmNoYXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuaW5uZXJUZXh0KSwgYnVpbGRRdWV1ZUl0ZW0oeyAuLi5zdGVwIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgbGV0IGdldFR5cGVhYmxlID0gKCkgPT4gcmF3VmFsdWVzKCkuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUudHlwZWFibGUpO1xuICBsZXQgc2V0ID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW0pIHtcbiAgICBsZXQga2V5cyA9IFsuLi5fcS5rZXlzKCldO1xuICAgIF9xLnNldChrZXlzW2luZGV4XSwgYnVpbGRRdWV1ZUl0ZW0oaXRlbSkpO1xuICB9O1xuICBsZXQgYnVpbGRRdWV1ZUl0ZW0gPSAocXVldWVJdGVtKSA9PiB7XG4gICAgcXVldWVJdGVtLnNob3VsZFBhdXNlQ3Vyc29yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnR5cGVhYmxlIHx8IHRoaXMuY3Vyc29yYWJsZSB8fCB0aGlzLmRlbGV0YWJsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcXVldWVJdGVtO1xuICB9O1xuICBsZXQgcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBfcS5mb3JFYWNoKChpdGVtKSA9PiBkZWxldGUgaXRlbS5kb25lKTtcbiAgfTtcbiAgbGV0IHdpcGUgPSBmdW5jdGlvbigpIHtcbiAgICBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgYWRkKGluaXRpYWxJdGVtcyk7XG4gIH07XG4gIGxldCBnZXRRdWV1ZSA9ICgpID0+IF9xO1xuICBsZXQgcmF3VmFsdWVzID0gKCkgPT4gQXJyYXkuZnJvbShfcS52YWx1ZXMoKSk7XG4gIGxldCBkZXN0cm95ID0gKGtleSkgPT4gX3EuZGVsZXRlKGtleSk7XG4gIGxldCBnZXRJdGVtcyA9IChhbGwgPSBmYWxzZSkgPT4gYWxsID8gcmF3VmFsdWVzKCkgOiByYXdWYWx1ZXMoKS5maWx0ZXIoKGkpID0+ICFpLmRvbmUpO1xuICBsZXQgZG9uZSA9IChrZXksIHNob3VsZERlc3Ryb3kgPSBmYWxzZSkgPT4gc2hvdWxkRGVzdHJveSA/IF9xLmRlbGV0ZShrZXkpIDogX3EuZ2V0KGtleSkuZG9uZSA9IHRydWU7XG4gIGxldCBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGFkZChpbml0aWFsSXRlbXMpO1xuICByZXR1cm4ge1xuICAgIGFkZCxcbiAgICBzZXQsXG4gICAgd2lwZSxcbiAgICBkb25lLFxuICAgIHJlc2V0LFxuICAgIGRlc3Ryb3ksXG4gICAgZ2V0SXRlbXMsXG4gICAgZ2V0UXVldWUsXG4gICAgZ2V0VHlwZWFibGVcbiAgfTtcbn07XG5jb25zdCBEQVRBX0FUVFJJQlVURSA9IFwiZGF0YS10eXBlaXQtaWRcIjtcbmNvbnN0IENVUlNPUl9DTEFTUyA9IFwidGktY3Vyc29yXCI7XG5jb25zdCBFTkQgPSBcIkVORFwiO1xuY29uc3QgREVGQVVMVF9TVEFUVVNFUyA9IHtcbiAgc3RhcnRlZDogZmFsc2UsXG4gIGNvbXBsZXRlZDogZmFsc2UsXG4gIGZyb3plbjogZmFsc2UsXG4gIGRlc3Ryb3llZDogZmFsc2Vcbn07XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGJyZWFrTGluZXM6IHRydWUsXG4gIGN1cnNvcjoge1xuICAgIGF1dG9QYXVzZTogdHJ1ZSxcbiAgICBhdXRvUGF1c2VEZWxheTogNTAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZnJhbWVzOiBbMCwgMCwgMV0ubWFwKChuKSA9PiB7XG4gICAgICAgIHJldHVybiB7IG9wYWNpdHk6IG4gfTtcbiAgICAgIH0pLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBpdGVyYXRpb25zOiBJbmZpbml0eSxcbiAgICAgICAgZWFzaW5nOiBcInN0ZXBzKDIsIHN0YXJ0KVwiLFxuICAgICAgICBmaWxsOiBcImZvcndhcmRzXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGN1cnNvckNoYXI6IFwifFwiLFxuICBjdXJzb3JTcGVlZDogMWUzLFxuICBkZWxldGVTcGVlZDogbnVsbCxcbiAgaHRtbDogdHJ1ZSxcbiAgbGlmZUxpa2U6IHRydWUsXG4gIGxvb3A6IGZhbHNlLFxuICBsb29wRGVsYXk6IDc1MCxcbiAgbmV4dFN0cmluZ0RlbGF5OiA3NTAsXG4gIHNwZWVkOiAxMDAsXG4gIHN0YXJ0RGVsYXk6IDI1MCxcbiAgc3RhcnREZWxldGU6IGZhbHNlLFxuICBzdHJpbmdzOiBbXSxcbiAgd2FpdFVudGlsVmlzaWJsZTogZmFsc2UsXG4gIGJlZm9yZVN0cmluZzogKCkgPT4ge1xuICB9LFxuICBhZnRlclN0cmluZzogKCkgPT4ge1xuICB9LFxuICBiZWZvcmVTdGVwOiAoKSA9PiB7XG4gIH0sXG4gIGFmdGVyU3RlcDogKCkgPT4ge1xuICB9LFxuICBhZnRlckNvbXBsZXRlOiAoKSA9PiB7XG4gIH1cbn07XG5jb25zdCBQTEFDRUhPTERFUl9DU1MgPSBgWyR7REFUQV9BVFRSSUJVVEV9XTpiZWZvcmUge2NvbnRlbnQ6ICcuJzsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMDsgdmlzaWJpbGl0eTogaGlkZGVuO31gO1xuY29uc3QgY3JlYXRlRWxlbWVudCA9IChlbCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbCk7XG5jb25zdCBjcmVhdGVUZXh0Tm9kZSA9IChjb250ZW50KSA9PiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KTtcbmNvbnN0IGFwcGVuZFN0eWxlQmxvY2sgPSAoc3R5bGVzLCBpZCA9IFwiXCIpID0+IHtcbiAgbGV0IHN0eWxlQmxvY2sgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlQmxvY2suaWQgPSBpZDtcbiAgc3R5bGVCbG9jay5hcHBlbmRDaGlsZChjcmVhdGVUZXh0Tm9kZShzdHlsZXMpKTtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUJsb2NrKTtcbn07XG5jb25zdCBjYWxjdWxhdGVEZWxheSA9IChkZWxheUFyZykgPT4ge1xuICBpZiAoIWlzQXJyYXkoZGVsYXlBcmcpKSB7XG4gICAgZGVsYXlBcmcgPSBbZGVsYXlBcmcgLyAyLCBkZWxheUFyZyAvIDJdO1xuICB9XG4gIHJldHVybiBkZWxheUFyZztcbn07XG5jb25zdCByYW5kb21JblJhbmdlID0gKHZhbHVlLCByYW5nZTIpID0+IHtcbiAgcmV0dXJuIE1hdGguYWJzKFxuICAgIE1hdGgucmFuZG9tKCkgKiAodmFsdWUgKyByYW5nZTIgLSAodmFsdWUgLSByYW5nZTIpKSArICh2YWx1ZSAtIHJhbmdlMilcbiAgKTtcbn07XG5sZXQgcmFuZ2UgPSAodmFsKSA9PiB2YWwgLyAyO1xuZnVuY3Rpb24gY2FsY3VsYXRlUGFjZShvcHRpb25zKSB7XG4gIGxldCB7IHNwZWVkLCBkZWxldGVTcGVlZCwgbGlmZUxpa2UgfSA9IG9wdGlvbnM7XG4gIGRlbGV0ZVNwZWVkID0gZGVsZXRlU3BlZWQgIT09IG51bGwgPyBkZWxldGVTcGVlZCA6IHNwZWVkIC8gMztcbiAgcmV0dXJuIGxpZmVMaWtlID8gW1xuICAgIHJhbmRvbUluUmFuZ2Uoc3BlZWQsIHJhbmdlKHNwZWVkKSksXG4gICAgcmFuZG9tSW5SYW5nZShkZWxldGVTcGVlZCwgcmFuZ2UoZGVsZXRlU3BlZWQpKVxuICBdIDogW3NwZWVkLCBkZWxldGVTcGVlZF07XG59XG5jb25zdCB0b0FycmF5ID0gKHZhbCkgPT4gQXJyYXkuZnJvbSh2YWwpO1xubGV0IGV4cGFuZFRleHROb2RlcyA9IChlbGVtZW50KSA9PiB7XG4gIFsuLi5lbGVtZW50LmNoaWxkTm9kZXNdLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgWy4uLmNoaWxkLm5vZGVWYWx1ZV0uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICBjaGlsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjcmVhdGVUZXh0Tm9kZShjKSwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhwYW5kVGV4dE5vZGVzKGNoaWxkKTtcbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcbmNvbnN0IGdldFBhcnNlZEJvZHkgPSAoY29udGVudCkgPT4ge1xuICBsZXQgZG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGRvYy5ib2R5LmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gIHJldHVybiBleHBhbmRUZXh0Tm9kZXMoZG9jLmJvZHkpO1xufTtcbmZ1bmN0aW9uIHdhbGtFbGVtZW50Tm9kZXMoZWxlbWVudCwgc2hvdWxkUmV2ZXJzZSA9IGZhbHNlLCBzaG91bGRJbmNsdWRlQ3Vyc29yID0gZmFsc2UpIHtcbiAgbGV0IGN1cnNvciA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Q1VSU09SX0NMQVNTfWApO1xuICBsZXQgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfQUxMLCB7XG4gICAgYWNjZXB0Tm9kZTogKG5vZGUpID0+IHtcbiAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgaWYgKGN1cnNvciAmJiBzaG91bGRJbmNsdWRlQ3Vyc29yKSB7XG4gICAgICAgIGlmICgoX2EyID0gbm9kZS5jbGFzc0xpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuY29udGFpbnMoQ1VSU09SX0NMQVNTKSkge1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnNvci5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoKF9iID0gbm9kZS5jbGFzc0xpc3QpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250YWlucyhDVVJTT1JfQ0xBU1MpKSA/IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCA6IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG4gIH0pO1xuICBsZXQgbmV4dE5vZGU7XG4gIGxldCBub2RlcyA9IFtdO1xuICB3aGlsZSAobmV4dE5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgIGlmICghbmV4dE5vZGUub3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgIG5leHROb2RlLm9yaWdpbmFsUGFyZW50ID0gbmV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgbm9kZXMucHVzaChuZXh0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFJldmVyc2UgPyBub2Rlcy5yZXZlcnNlKCkgOiBub2Rlcztcbn1cbmZ1bmN0aW9uIGNodW5rU3RyaW5nQXNIdG1sKHN0cmluZykge1xuICByZXR1cm4gd2Fsa0VsZW1lbnROb2RlcyhnZXRQYXJzZWRCb2R5KHN0cmluZykpO1xufVxuZnVuY3Rpb24gbWF5YmVDaHVua1N0cmluZ0FzSHRtbChzdHIsIGFzSHRtbCA9IHRydWUpIHtcbiAgcmV0dXJuIGFzSHRtbCA/IGNodW5rU3RyaW5nQXNIdG1sKHN0cikgOiB0b0FycmF5KHN0cikubWFwKGNyZWF0ZVRleHROb2RlKTtcbn1cbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGNvdW50U3RlcHNUb1NlbGVjdG9yID0gKHtcbiAgcXVldWVJdGVtcyxcbiAgc2VsZWN0b3IsXG4gIGN1cnNvclBvc2l0aW9uLFxuICB0b1xufSkgPT4ge1xuICBpZiAoaXNOdW1iZXIoc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yICogLTE7XG4gIH1cbiAgbGV0IGlzTW92aW5nVG9FbmQgPSBuZXcgUmVnRXhwKEVORCwgXCJpXCIpLnRlc3QodG8pO1xuICBsZXQgc2VsZWN0b3JJbmRleCA9IHNlbGVjdG9yID8gWy4uLnF1ZXVlSXRlbXNdLnJldmVyc2UoKS5maW5kSW5kZXgoKHsgY2hhciB9KSA9PiB7XG4gICAgbGV0IHBhcmVudEVsZW1lbnQgPSBjaGFyLnBhcmVudEVsZW1lbnQ7XG4gICAgbGV0IHBhcmVudE1hdGNoZXMgPSBwYXJlbnRFbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIGlmIChpc01vdmluZ1RvRW5kICYmIHBhcmVudE1hdGNoZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50TWF0Y2hlcyAmJiBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQuaXNTYW1lTm9kZShjaGFyKTtcbiAgfSkgOiAtMTtcbiAgaWYgKHNlbGVjdG9ySW5kZXggPCAwKSB7XG4gICAgc2VsZWN0b3JJbmRleCA9IGlzTW92aW5nVG9FbmQgPyAwIDogcXVldWVJdGVtcy5sZW5ndGggLSAxO1xuICB9XG4gIGxldCBvZmZzZXQgPSBpc01vdmluZ1RvRW5kID8gMCA6IDE7XG4gIHJldHVybiBzZWxlY3RvckluZGV4IC0gY3Vyc29yUG9zaXRpb24gKyBvZmZzZXQ7XG59O1xuY29uc3QgZGVzdHJveVRpbWVvdXRzID0gKHRpbWVvdXRzKSA9PiB7XG4gIHRpbWVvdXRzLmZvckVhY2goY2xlYXJUaW1lb3V0KTtcbiAgcmV0dXJuIFtdO1xufTtcbmNvbnN0IGR1cGxpY2F0ZSA9ICh2YWx1ZSwgdGltZXMpID0+IG5ldyBBcnJheSh0aW1lcykuZmlsbCh2YWx1ZSk7XG5sZXQgYmVmb3JlUGFpbnQgPSAoY2IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFzeW5jICgpID0+IHtcbiAgICAgIHJlc29sdmUoYXdhaXQgY2IoKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmxldCBnZXRBbmltYXRpb25Gcm9tRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LmdldEFuaW1hdGlvbnMoKS5maW5kKChhbmltYXRpb24pID0+IHtcbiAgICByZXR1cm4gYW5pbWF0aW9uLmlkID09PSBlbGVtZW50LmRhdGFzZXQudGlBbmltYXRpb25JZDtcbiAgfSk7XG59O1xubGV0IHNldEN1cnNvckFuaW1hdGlvbiA9ICh7XG4gIGN1cnNvcixcbiAgZnJhbWVzLFxuICBvcHRpb25zXG59KSA9PiB7XG4gIGxldCBhbmltYXRpb24gPSBjdXJzb3IuYW5pbWF0ZShmcmFtZXMsIG9wdGlvbnMpO1xuICBhbmltYXRpb24ucGF1c2UoKTtcbiAgYW5pbWF0aW9uLmlkID0gY3Vyc29yLmRhdGFzZXQudGlBbmltYXRpb25JZDtcbiAgYmVmb3JlUGFpbnQoKCkgPT4ge1xuICAgIGJlZm9yZVBhaW50KCgpID0+IHtcbiAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYW5pbWF0aW9uO1xufTtcbmxldCByZWJ1aWxkQ3Vyc29yQW5pbWF0aW9uID0gKHtcbiAgY3Vyc29yLFxuICBvcHRpb25zLFxuICBjdXJzb3JPcHRpb25zXG59KSA9PiB7XG4gIGlmICghY3Vyc29yIHx8ICFjdXJzb3JPcHRpb25zKVxuICAgIHJldHVybjtcbiAgbGV0IGFuaW1hdGlvbiA9IGdldEFuaW1hdGlvbkZyb21FbGVtZW50KGN1cnNvcik7XG4gIGxldCBvbGRDdXJyZW50VGltZTtcbiAgaWYgKGFuaW1hdGlvbikge1xuICAgIG9wdGlvbnMuZGVsYXkgPSBhbmltYXRpb24uZWZmZWN0LmdldENvbXB1dGVkVGltaW5nKCkuZGVsYXk7XG4gICAgb2xkQ3VycmVudFRpbWUgPSBhbmltYXRpb24uY3VycmVudFRpbWU7XG4gICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICB9XG4gIGxldCBuZXdBbmltYXRpb24gPSBzZXRDdXJzb3JBbmltYXRpb24oe1xuICAgIGN1cnNvcixcbiAgICBmcmFtZXM6IGN1cnNvck9wdGlvbnMuYW5pbWF0aW9uLmZyYW1lcyxcbiAgICBvcHRpb25zXG4gIH0pO1xuICBpZiAob2xkQ3VycmVudFRpbWUpIHtcbiAgICBuZXdBbmltYXRpb24uY3VycmVudFRpbWUgPSBvbGRDdXJyZW50VGltZTtcbiAgfVxuICByZXR1cm4gbmV3QW5pbWF0aW9uO1xufTtcbmxldCBleGVjdXRlID0gKHF1ZXVlSXRlbSkgPT4ge1xuICB2YXIgX2EyO1xuICByZXR1cm4gKF9hMiA9IHF1ZXVlSXRlbS5mdW5jKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNhbGwobnVsbCk7XG59O1xubGV0IGZpcmVJdGVtID0gYXN5bmMgKHtcbiAgaW5kZXgsXG4gIHF1ZXVlSXRlbXMsXG4gIHdhaXQ6IHdhaXQyLFxuICBjdXJzb3IsXG4gIGN1cnNvck9wdGlvbnNcbn0pID0+IHtcbiAgbGV0IHF1ZXVlSXRlbSA9IHF1ZXVlSXRlbXNbaW5kZXhdWzFdO1xuICBsZXQgaW5zdGFudFF1ZXVlID0gW107XG4gIGxldCB0ZW1wSW5kZXggPSBpbmRleDtcbiAgbGV0IGZ1dHVyZUl0ZW0gPSBxdWV1ZUl0ZW07XG4gIGxldCBzaG91bGRCZUdyb3VwZWQgPSAoKSA9PiBmdXR1cmVJdGVtICYmICFmdXR1cmVJdGVtLmRlbGF5O1xuICBsZXQgc2hvdWxkUGF1c2VDdXJzb3IgPSBxdWV1ZUl0ZW0uc2hvdWxkUGF1c2VDdXJzb3IoKSAmJiBjdXJzb3JPcHRpb25zLmF1dG9QYXVzZTtcbiAgd2hpbGUgKHNob3VsZEJlR3JvdXBlZCgpKSB7XG4gICAgaW5zdGFudFF1ZXVlLnB1c2goZnV0dXJlSXRlbSk7XG4gICAgc2hvdWxkQmVHcm91cGVkKCkgJiYgdGVtcEluZGV4Kys7XG4gICAgZnV0dXJlSXRlbSA9IHF1ZXVlSXRlbXNbdGVtcEluZGV4XSA/IHF1ZXVlSXRlbXNbdGVtcEluZGV4XVsxXSA6IG51bGw7XG4gIH1cbiAgaWYgKGluc3RhbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICBhd2FpdCBiZWZvcmVQYWludChhc3luYyAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBxIG9mIGluc3RhbnRRdWV1ZSkge1xuICAgICAgICBhd2FpdCBleGVjdXRlKHEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZW1wSW5kZXggLSAxO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSBnZXRBbmltYXRpb25Gcm9tRWxlbWVudChjdXJzb3IpO1xuICBsZXQgb3B0aW9ucztcbiAgaWYgKGFuaW1hdGlvbikge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5hbmltYXRpb24uZWZmZWN0LmdldENvbXB1dGVkVGltaW5nKCksXG4gICAgICBkZWxheTogc2hvdWxkUGF1c2VDdXJzb3IgPyBjdXJzb3JPcHRpb25zLmF1dG9QYXVzZURlbGF5IDogMFxuICAgIH07XG4gIH1cbiAgYXdhaXQgd2FpdDIoYXN5bmMgKCkgPT4ge1xuICAgIGlmIChhbmltYXRpb24gJiYgc2hvdWxkUGF1c2VDdXJzb3IpIHtcbiAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICB9XG4gICAgYXdhaXQgYmVmb3JlUGFpbnQoKCkgPT4ge1xuICAgICAgZXhlY3V0ZShxdWV1ZUl0ZW0pO1xuICAgIH0pO1xuICB9LCBxdWV1ZUl0ZW0uZGVsYXkpO1xuICBhd2FpdCByZWJ1aWxkQ3Vyc29yQW5pbWF0aW9uKHtcbiAgICBjdXJzb3IsXG4gICAgb3B0aW9ucyxcbiAgICBjdXJzb3JPcHRpb25zXG4gIH0pO1xuICByZXR1cm4gaW5kZXg7XG59O1xuY29uc3QgZmlyZVdoZW5WaXNpYmxlID0gKGVsZW1lbnQsIGZ1bmMpID0+IHtcbiAgbGV0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKFxuICAgIChlbnRyaWVzLCBvYnNlcnZlcjIpID0+IHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgZnVuYygpO1xuICAgICAgICAgIG9ic2VydmVyMi51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgeyB0aHJlc2hvbGQ6IDEgfVxuICApO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xufTtcbmNvbnN0IGdlbmVyYXRlSGFzaCA9ICgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgOSk7XG5jb25zdCBpc0lucHV0ID0gKGVsKSA9PiB7XG4gIHJldHVybiBcInZhbHVlXCIgaW4gZWw7XG59O1xubGV0IGdldEFsbENoYXJzID0gKGVsZW1lbnQpID0+IHtcbiAgaWYgKGlzSW5wdXQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gdG9BcnJheShlbGVtZW50LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gd2Fsa0VsZW1lbnROb2RlcyhlbGVtZW50LCB0cnVlKS5maWx0ZXIoXG4gICAgKGMpID0+ICEoYy5jaGlsZE5vZGVzLmxlbmd0aCA+IDApXG4gICk7XG59O1xubGV0IGhhbmRsZUZ1bmN0aW9uYWxBcmcgPSAoYXJnKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoKSA6IGFyZztcbn07XG5sZXQgc2VsZWN0ID0gKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQsIGFsbCA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiBlbGVtZW50W2BxdWVyeVNlbGVjdG9yJHthbGwgPyBcIkFsbFwiIDogXCJcIn1gXShzZWxlY3Rvcik7XG59O1xubGV0IGlzQm9keUVsZW1lbnQgPSAobm9kZSkgPT4gL2JvZHkvaS50ZXN0KG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGFnTmFtZSk7XG5sZXQgaW5zZXJ0SW50b0VsZW1lbnQgPSAob3JpZ2luYWxUYXJnZXQsIGNoYXJhY3RlcikgPT4ge1xuICBpZiAoaXNJbnB1dChvcmlnaW5hbFRhcmdldCkpIHtcbiAgICBvcmlnaW5hbFRhcmdldC52YWx1ZSA9IGAke29yaWdpbmFsVGFyZ2V0LnZhbHVlfSR7Y2hhcmFjdGVyLnRleHRDb250ZW50fWA7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNoYXJhY3Rlci5pbm5lckhUTUwgPSBcIlwiO1xuICBsZXQgdGFyZ2V0ID0gaXNCb2R5RWxlbWVudChjaGFyYWN0ZXIub3JpZ2luYWxQYXJlbnQpID8gb3JpZ2luYWxUYXJnZXQgOiAoXG4gICAgLy8gSWYgd2UgYWRkIG9uZS1vZmYgZnJlc2ggZWxlbWVudHMsIHRoZXJlIHdpbGwgYmUgbm9cbiAgICAvLyBcIm9yaWdpbmFsUGFyZW50XCIsIHNvIGFsd2F5cyBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgdGFyZ2V0LlxuICAgIGNoYXJhY3Rlci5vcmlnaW5hbFBhcmVudCB8fCBvcmlnaW5hbFRhcmdldFxuICApO1xuICB0YXJnZXQuaW5zZXJ0QmVmb3JlKFxuICAgIGNoYXJhY3RlcixcbiAgICBzZWxlY3QoXCIuXCIgKyBDVVJTT1JfQ0xBU1MsIHRhcmdldCkgfHwgbnVsbFxuICApO1xufTtcbmNvbnN0IGlzTm9uVm9pZEVsZW1lbnQgPSAoZWwpID0+IC88KC4rKT4oLio/KTxcXC8oLispPi8udGVzdChlbC5vdXRlckhUTUwpO1xuY29uc3QgbWVyZ2UgPSAob3JpZ2luYWxPYmosIG5ld09iaikgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxPYmosIG5ld09iaik7XG5sZXQgcHJvY2Vzc0N1cnNvck9wdGlvbnMgPSAoY3Vyc29yT3B0aW9ucykgPT4ge1xuICB2YXIgX2EyLCBfYjtcbiAgaWYgKHR5cGVvZiBjdXJzb3JPcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IG5ld09wdGlvbnMgPSB7fTtcbiAgICBsZXQgeyBmcmFtZXM6IGRlZmF1bHRGcmFtZXMsIG9wdGlvbnM6IGRlZmF1bHRPcHRpb25zIH0gPSBERUZBVUxUX09QVElPTlMuY3Vyc29yLmFuaW1hdGlvbjtcbiAgICBuZXdPcHRpb25zLmFuaW1hdGlvbiA9IGN1cnNvck9wdGlvbnMuYW5pbWF0aW9uIHx8IHt9O1xuICAgIG5ld09wdGlvbnMuYW5pbWF0aW9uLmZyYW1lcyA9ICgoX2EyID0gY3Vyc29yT3B0aW9ucy5hbmltYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZnJhbWVzKSB8fCBkZWZhdWx0RnJhbWVzO1xuICAgIG5ld09wdGlvbnMuYW5pbWF0aW9uLm9wdGlvbnMgPSBtZXJnZShcbiAgICAgIGRlZmF1bHRPcHRpb25zLFxuICAgICAgKChfYiA9IGN1cnNvck9wdGlvbnMuYW5pbWF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3B0aW9ucykgfHwge31cbiAgICApO1xuICAgIG5ld09wdGlvbnMuYXV0b1BhdXNlID0gY3Vyc29yT3B0aW9ucy5hdXRvUGF1c2UgPz8gREVGQVVMVF9PUFRJT05TLmN1cnNvci5hdXRvUGF1c2U7XG4gICAgbmV3T3B0aW9ucy5hdXRvUGF1c2VEZWxheSA9IGN1cnNvck9wdGlvbnMuYXV0b1BhdXNlRGVsYXkgfHwgREVGQVVMVF9PUFRJT05TLmN1cnNvci5hdXRvUGF1c2VEZWxheTtcbiAgICByZXR1cm4gbmV3T3B0aW9ucztcbiAgfVxuICBpZiAoY3Vyc29yT3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBERUZBVUxUX09QVElPTlMuY3Vyc29yO1xuICB9XG4gIHJldHVybiBjdXJzb3JPcHRpb25zO1xufTtcbmNvbnN0IHJlbW92ZU5vZGUgPSAobm9kZSwgcm9vdEVsZW1lbnQpID0+IHtcbiAgaWYgKCFub2RlKVxuICAgIHJldHVybjtcbiAgbGV0IG5vZGVQYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGxldCBub2RlVG9SZW1vdmUgPSBub2RlUGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSB8fCBub2RlUGFyZW50LmlzU2FtZU5vZGUocm9vdEVsZW1lbnQpID8gKFxuICAgIC8vIFRoaXMgcGFyZW50IHN0aWxsIG5lZWRzIHRvIGV4aXN0LlxuICAgIG5vZGVcbiAgKSA6IChcbiAgICAvLyBUaGVyZSdzIG5vdGhpbmcgZWxzZSBpbiB0aGVyZSwgc28ganVzdCBkZWxldGUgdGhlIGVudGlyZSB0aGluZy5cbiAgICAvLyBCeSBkb2luZyB0aGlzLCB3ZSBjbGVhbiB1cCBtYXJrdXAgYXMgd2UgZ28gYWxvbmcuXG4gICAgbm9kZVBhcmVudFxuICApO1xuICBub2RlVG9SZW1vdmUucmVtb3ZlKCk7XG59O1xuY29uc3QgcmVwb3NpdGlvbkN1cnNvciA9IChlbGVtZW50LCBhbGxDaGFycywgbmV3Q3Vyc29yUG9zaXRpb24pID0+IHtcbiAgbGV0IG5vZGVUb0luc2VydEJlZm9yZSA9IGFsbENoYXJzW25ld0N1cnNvclBvc2l0aW9uIC0gMV07XG4gIGxldCBjdXJzb3IgPSBzZWxlY3QoYC4ke0NVUlNPUl9DTEFTU31gLCBlbGVtZW50KTtcbiAgZWxlbWVudCA9IChub2RlVG9JbnNlcnRCZWZvcmUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVUb0luc2VydEJlZm9yZS5wYXJlbnROb2RlKSB8fCBlbGVtZW50O1xuICBlbGVtZW50Lmluc2VydEJlZm9yZShjdXJzb3IsIG5vZGVUb0luc2VydEJlZm9yZSB8fCBudWxsKTtcbn07XG5mdW5jdGlvbiBzZWxlY3RvclRvRWxlbWVudCh0aGluZykge1xuICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSBcInN0cmluZ1wiID8gc2VsZWN0KHRoaW5nKSA6IHRoaW5nO1xufVxubGV0IGN1cnNvckZvbnRTdHlsZXMgPSB7XG4gIFwiZm9udC1mYW1pbHlcIjogXCJcIixcbiAgXCJmb250LXdlaWdodFwiOiBcIlwiLFxuICBcImZvbnQtc2l6ZVwiOiBcIlwiLFxuICBcImZvbnQtc3R5bGVcIjogXCJcIixcbiAgXCJsaW5lLWhlaWdodFwiOiBcIlwiLFxuICBjb2xvcjogXCJcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLS4xMjVlbSlcIlxufTtcbmxldCBzZXRDdXJzb3JTdHlsZXMgPSAoaWQsIGVsZW1lbnQpID0+IHtcbiAgbGV0IHJvb3RTZWxlY3RvciA9IGBbJHtEQVRBX0FUVFJJQlVURX09JyR7aWR9J11gO1xuICBsZXQgY3Vyc29yU2VsZWN0b3IgPSBgJHtyb290U2VsZWN0b3J9IC4ke0NVUlNPUl9DTEFTU31gO1xuICBsZXQgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBsZXQgY3VzdG9tUHJvcGVydGllcyA9IE9iamVjdC5lbnRyaWVzKGN1cnNvckZvbnRTdHlsZXMpLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIFtpdGVtLCB2YWx1ZV0pID0+IHtcbiAgICAgIHJldHVybiBgJHthY2N1bXVsYXRvcn0gJHtpdGVtfTogdmFyKC0tdGktY3Vyc29yLSR7aXRlbX0sICR7dmFsdWUgfHwgY29tcHV0ZWRTdHlsZXNbaXRlbV19KTtgO1xuICAgIH0sXG4gICAgXCJcIlxuICApO1xuICBhcHBlbmRTdHlsZUJsb2NrKFxuICAgIGAke2N1cnNvclNlbGVjdG9yfSB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDA7ICR7Y3VzdG9tUHJvcGVydGllc30gfWAsXG4gICAgaWRcbiAgKTtcbn07XG5mdW5jdGlvbiBzcGxpdE9uQnJlYWsoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvPCEtLSguKz8pLS0+L2csIFwiXCIpLnRyaW0oKS5zcGxpdCgvPGJyKD86XFxzKj8pKD86XFwvKT8+Lyk7XG59XG5sZXQgdXBkYXRlQ3Vyc29yUG9zaXRpb24gPSAoc3RlcHMsIGN1cnNvclBvc2l0aW9uLCBwcmludGVkQ2hhcmFjdGVycykgPT4ge1xuICByZXR1cm4gTWF0aC5taW4oXG4gICAgTWF0aC5tYXgoY3Vyc29yUG9zaXRpb24gKyBzdGVwcywgMCksXG4gICAgcHJpbnRlZENoYXJhY3RlcnMubGVuZ3RoXG4gICk7XG59O1xubGV0IHdhaXQgPSAoY2FsbGJhY2ssIGRlbGF5LCB0aW1lb3V0cykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsZXQgY2IgPSBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgdGltZW91dHMucHVzaChzZXRUaW1lb3V0KGNiLCBkZWxheSB8fCAwKSk7XG4gIH0pO1xufTtcbmxldCBUeXBlSXQkMSA9IChfYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbXB0eSk7XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBpdGVtcyBpbiB0aGUgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVtZW1iZXIgSWYgZmFsc2UsIGVhY2ggcXVldWUgaXRlbSB3aWxsIGJlIGRlc3Ryb3llZCBvbmNlIGV4ZWN1dGVkLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9maXJlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21vdmUpO1xuICAgIC8qKlxuICAgICAqIDEuIFJlc2V0IHF1ZXVlLlxuICAgICAqIDIuIFJlc2V0IGluaXRpYWwgcGF1c2UuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcmVwTG9vcCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9maXJlSXRlbVdpdGhDb250ZXh0KTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3dhaXQpO1xuICAgIC8qKlxuICAgICAqIEF0dGFjaCBpdCB0byB0aGUgRE9NIHNvLCBhbG9uZyB3aXRoIHRoZSByZXF1aXJlZCBDU1MgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2F0dGFjaEN1cnNvcik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9lbGVtZW50SXNJbnB1dCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9xdWV1ZUFuZFJldHVybik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9tYXliZUFwcGVuZFBhdXNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF91cGRhdGVPcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBwcm92aWRlZCBzdHJpbmdzLCBnZW5lcmF0ZSBhIFR5cGVJdCBxdWV1ZVxuICAgICAqIHRvIGJlIGZpcmVkIGZvciBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZ2VuZXJhdGVRdWV1ZSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9wcmVwZW5kSGFyZGNvZGVkU3RyaW5ncyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZWQgaXQncyBhIG5vbi1mb3JtIGVsZW1lbnQgYW5kIHRoZSBvcHRpb25zIGlzIHByb3ZpZGVkLFxuICAgICAqIHNldCB1cCB0aGUgY3Vyc29yIGVsZW1lbnQgZm9yIHRoZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXRVcEN1cnNvcik7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hZGRTcGxpdFBhdXNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3R5cGUpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZGVsZXRlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX3JlbW92ZU5vZGUpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfZ2V0UGFjZSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9kZXJpdmVkQ3Vyc29yUG9zaXRpb24pO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaXNJbnB1dCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zaG91bGRSZW5kZXJDdXJzb3IpO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfYWxsQ2hhcnMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbGVtZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0aW1lb3V0c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Vyc29yUG9zaXRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZWRpY3RlZEN1cnNvclBvc2l0aW9uXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0dXNlc1wiLCB7XG4gICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICBmcm96ZW46IGZhbHNlLFxuICAgICAgZGVzdHJveWVkOiBmYWxzZVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcHRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicXVldWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImN1cnNvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5mcmVlemVcIiwgKCkgPT4ge1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1wiLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXR1c2VzW2tleV07XG4gICAgfSk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9idWlsZE9wdGlvbnMsIChvcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zLmN1cnNvciA9IHByb2Nlc3NDdXJzb3JPcHRpb25zKFxuICAgICAgICBvcHRpb25zLmN1cnNvciA/PyBERUZBVUxUX09QVElPTlMuY3Vyc29yXG4gICAgICApO1xuICAgICAgdGhpcy5vcHRzLnN0cmluZ3MgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX3ByZXBlbmRIYXJkY29kZWRTdHJpbmdzLCBwcmVwZW5kSGFyZGNvZGVkU3RyaW5nc19mbikuY2FsbCh0aGlzLCBhc0FycmF5KHRoaXMub3B0cy5zdHJpbmdzKSk7XG4gICAgICB0aGlzLm9wdHMgPSBtZXJnZSh0aGlzLm9wdHMsIHtcbiAgICAgICAgaHRtbDogIV9fcHJpdmF0ZUdldCh0aGlzLCBfaXNJbnB1dCwgaXNJbnB1dF9nZXQpICYmIHRoaXMub3B0cy5odG1sLFxuICAgICAgICBuZXh0U3RyaW5nRGVsYXk6IGNhbGN1bGF0ZURlbGF5KHRoaXMub3B0cy5uZXh0U3RyaW5nRGVsYXkpLFxuICAgICAgICBsb29wRGVsYXk6IGNhbGN1bGF0ZURlbGF5KHRoaXMub3B0cy5sb29wRGVsYXkpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLm9wdHMgPSBtZXJnZShERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudCA9IHNlbGVjdG9yVG9FbGVtZW50KGVsZW1lbnQpO1xuICAgIHRoaXMudGltZW91dHMgPSBbXTtcbiAgICB0aGlzLmN1cnNvclBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnVuZnJlZXplID0gKCkgPT4ge1xuICAgIH07XG4gICAgdGhpcy5wcmVkaWN0ZWRDdXJzb3JQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zdGF0dXNlcyA9IG1lcmdlKHt9LCBERUZBVUxUX1NUQVRVU0VTKTtcbiAgICB0aGlzLmlkID0gZ2VuZXJhdGVIYXNoKCk7XG4gICAgdGhpcy5xdWV1ZSA9IFF1ZXVlKFt7IGRlbGF5OiB0aGlzLm9wdHMuc3RhcnREZWxheSB9XSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF9idWlsZE9wdGlvbnMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5jdXJzb3IgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX3NldFVwQ3Vyc29yLCBzZXRVcEN1cnNvcl9mbikuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVsZW1lbnQuZGF0YXNldC50eXBlaXRJZCA9IHRoaXMuaWQ7XG4gICAgYXBwZW5kU3R5bGVCbG9jayhQTEFDRUhPTERFUl9DU1MpO1xuICAgIGlmICh0aGlzLm9wdHMuc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2VuZXJhdGVRdWV1ZSwgZ2VuZXJhdGVRdWV1ZV9mbikuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICAgKi9cbiAgZ28oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzZXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfYXR0YWNoQ3Vyc29yLCBhdHRhY2hDdXJzb3JfZm4pLmNhbGwodGhpcyk7XG4gICAgaWYgKCF0aGlzLm9wdHMud2FpdFVudGlsVmlzaWJsZSkge1xuICAgICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9maXJlLCBmaXJlX2ZuKS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpcmVXaGVuVmlzaWJsZSh0aGlzLmVsZW1lbnQsIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZmlyZSwgZmlyZV9mbikuYmluZCh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzdHJveShzaG91bGRSZW1vdmVDdXJzb3IgPSB0cnVlKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IGRlc3Ryb3lUaW1lb3V0cyh0aGlzLnRpbWVvdXRzKTtcbiAgICBoYW5kbGVGdW5jdGlvbmFsQXJnKHNob3VsZFJlbW92ZUN1cnNvcikgJiYgdGhpcy5jdXJzb3IgJiYgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9yZW1vdmVOb2RlLCByZW1vdmVOb2RlX2ZuKS5jYWxsKHRoaXMsIHRoaXMuY3Vyc29yKTtcbiAgICB0aGlzLnN0YXR1c2VzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cbiAgcmVzZXQocmVidWlsZCkge1xuICAgICF0aGlzLmlzKFwiZGVzdHJveWVkXCIpICYmIHRoaXMuZGVzdHJveSgpO1xuICAgIGlmIChyZWJ1aWxkKSB7XG4gICAgICB0aGlzLnF1ZXVlLndpcGUoKTtcbiAgICAgIHJlYnVpbGQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWUucmVzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdGhpcy5zdGF0dXNlcykge1xuICAgICAgdGhpcy5zdGF0dXNlc1twcm9wZXJ0eV0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50W19fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZWxlbWVudElzSW5wdXQsIGVsZW1lbnRJc0lucHV0X2ZuKS5jYWxsKHRoaXMpID8gXCJ2YWx1ZVwiIDogXCJpbm5lckhUTUxcIl0gPSBcIlwiO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHR5cGUoc3RyaW5nLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBzdHJpbmcgPSBoYW5kbGVGdW5jdGlvbmFsQXJnKHN0cmluZyk7XG4gICAgbGV0IHsgaW5zdGFudCB9ID0gYWN0aW9uT3B0cztcbiAgICBsZXQgYm9va0VuZFF1ZXVlSXRlbXMgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcywgZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zX2ZuKS5jYWxsKHRoaXMsIGFjdGlvbk9wdHMpO1xuICAgIGxldCBjaGFycyA9IG1heWJlQ2h1bmtTdHJpbmdBc0h0bWwoc3RyaW5nLCB0aGlzLm9wdHMuaHRtbCk7XG4gICAgbGV0IGNoYXJzQXNRdWV1ZUl0ZW1zID0gY2hhcnMubWFwKChjaGFyKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmdW5jOiAoKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3R5cGUsIHR5cGVfZm4pLmNhbGwodGhpcywgY2hhciksXG4gICAgICAgIGNoYXIsXG4gICAgICAgIGRlbGF5OiBpbnN0YW50IHx8IGlzTm9uVm9pZEVsZW1lbnQoY2hhcikgPyAwIDogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQYWNlLCBnZXRQYWNlX2ZuKS5jYWxsKHRoaXMpLFxuICAgICAgICB0eXBlYWJsZTogY2hhci5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IGl0ZW1zVG9RdWV1ZSA9IFtcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgeyBmdW5jOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLm9wdHMuYmVmb3JlU3RyaW5nKHN0cmluZywgdGhpcykgfSxcbiAgICAgIC4uLmNoYXJzQXNRdWV1ZUl0ZW1zLFxuICAgICAgeyBmdW5jOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLm9wdHMuYWZ0ZXJTdHJpbmcoc3RyaW5nLCB0aGlzKSB9LFxuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICBdO1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3F1ZXVlQW5kUmV0dXJuLCBxdWV1ZUFuZFJldHVybl9mbikuY2FsbCh0aGlzLCBpdGVtc1RvUXVldWUsIGFjdGlvbk9wdHMpO1xuICB9XG4gIGJyZWFrKGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3F1ZXVlQW5kUmV0dXJuLCBxdWV1ZUFuZFJldHVybl9mbikuY2FsbCh0aGlzLCB7XG4gICAgICBmdW5jOiAoKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3R5cGUsIHR5cGVfZm4pLmNhbGwodGhpcywgY3JlYXRlRWxlbWVudChcIkJSXCIpKSxcbiAgICAgIHR5cGVhYmxlOiB0cnVlXG4gICAgfSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgbW92ZShtb3ZlbWVudEFyZywgYWN0aW9uT3B0cyA9IHt9KSB7XG4gICAgbW92ZW1lbnRBcmcgPSBoYW5kbGVGdW5jdGlvbmFsQXJnKG1vdmVtZW50QXJnKTtcbiAgICBsZXQgYm9va0VuZFF1ZXVlSXRlbXMgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcywgZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zX2ZuKS5jYWxsKHRoaXMsIGFjdGlvbk9wdHMpO1xuICAgIGxldCB7IGluc3RhbnQsIHRvIH0gPSBhY3Rpb25PcHRzO1xuICAgIGxldCBudW1iZXJPZlN0ZXBzID0gY291bnRTdGVwc1RvU2VsZWN0b3Ioe1xuICAgICAgcXVldWVJdGVtczogdGhpcy5xdWV1ZS5nZXRUeXBlYWJsZSgpLFxuICAgICAgc2VsZWN0b3I6IG1vdmVtZW50QXJnID09PSBudWxsID8gXCJcIiA6IG1vdmVtZW50QXJnLFxuICAgICAgdG8sXG4gICAgICBjdXJzb3JQb3NpdGlvbjogX19wcml2YXRlR2V0KHRoaXMsIF9kZXJpdmVkQ3Vyc29yUG9zaXRpb24sIGRlcml2ZWRDdXJzb3JQb3NpdGlvbl9nZXQpXG4gICAgfSk7XG4gICAgbGV0IGRpcmVjdGlvbmFsU3RlcCA9IG51bWJlck9mU3RlcHMgPCAwID8gLTEgOiAxO1xuICAgIHRoaXMucHJlZGljdGVkQ3Vyc29yUG9zaXRpb24gPSBfX3ByaXZhdGVHZXQodGhpcywgX2Rlcml2ZWRDdXJzb3JQb3NpdGlvbiwgZGVyaXZlZEN1cnNvclBvc2l0aW9uX2dldCkgKyBudW1iZXJPZlN0ZXBzO1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3F1ZXVlQW5kUmV0dXJuLCBxdWV1ZUFuZFJldHVybl9mbikuY2FsbCh0aGlzLCBbXG4gICAgICBib29rRW5kUXVldWVJdGVtc1swXSxcbiAgICAgIC4uLmR1cGxpY2F0ZShcbiAgICAgICAge1xuICAgICAgICAgIGZ1bmM6ICgpID0+IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfbW92ZSwgbW92ZV9mbikuY2FsbCh0aGlzLCBkaXJlY3Rpb25hbFN0ZXApLFxuICAgICAgICAgIGRlbGF5OiBpbnN0YW50ID8gMCA6IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2V0UGFjZSwgZ2V0UGFjZV9mbikuY2FsbCh0aGlzKSxcbiAgICAgICAgICBjdXJzb3JhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIE1hdGguYWJzKG51bWJlck9mU3RlcHMpXG4gICAgICApLFxuICAgICAgYm9va0VuZFF1ZXVlSXRlbXNbMV1cbiAgICBdLCBhY3Rpb25PcHRzKTtcbiAgfVxuICBleGVjKGZ1bmMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIGxldCBib29rRW5kUXVldWVJdGVtcyA9IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zLCBnZW5lcmF0ZVRlbXBvcmFyeU9wdGlvblF1ZXVlSXRlbXNfZm4pLmNhbGwodGhpcywgYWN0aW9uT3B0cyk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcXVldWVBbmRSZXR1cm4sIHF1ZXVlQW5kUmV0dXJuX2ZuKS5jYWxsKHRoaXMsIFtib29rRW5kUXVldWVJdGVtc1swXSwgeyBmdW5jOiAoKSA9PiBmdW5jKHRoaXMpIH0sIGJvb2tFbmRRdWV1ZUl0ZW1zWzFdXSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgb3B0aW9ucyhvcHRzLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBvcHRzID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhvcHRzKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX3VwZGF0ZU9wdGlvbnMsIHVwZGF0ZU9wdGlvbnNfZm4pLmNhbGwodGhpcywgb3B0cyk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcXVldWVBbmRSZXR1cm4sIHF1ZXVlQW5kUmV0dXJuX2ZuKS5jYWxsKHRoaXMsIHt9LCBhY3Rpb25PcHRzKTtcbiAgfVxuICBwYXVzZShtaWxsaXNlY29uZHMsIGFjdGlvbk9wdHMgPSB7fSkge1xuICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3F1ZXVlQW5kUmV0dXJuLCBxdWV1ZUFuZFJldHVybl9mbikuY2FsbCh0aGlzLCB7IGRlbGF5OiBoYW5kbGVGdW5jdGlvbmFsQXJnKG1pbGxpc2Vjb25kcykgfSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgZGVsZXRlKG51bUNoYXJhY3RlcnMgPSBudWxsLCBhY3Rpb25PcHRzID0ge30pIHtcbiAgICBudW1DaGFyYWN0ZXJzID0gaGFuZGxlRnVuY3Rpb25hbEFyZyhudW1DaGFyYWN0ZXJzKTtcbiAgICBsZXQgYm9va0VuZFF1ZXVlSXRlbXMgPSBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcywgZ2VuZXJhdGVUZW1wb3JhcnlPcHRpb25RdWV1ZUl0ZW1zX2ZuKS5jYWxsKHRoaXMsIGFjdGlvbk9wdHMpO1xuICAgIGxldCBudW0gPSBudW1DaGFyYWN0ZXJzO1xuICAgIGxldCB7IGluc3RhbnQsIHRvIH0gPSBhY3Rpb25PcHRzO1xuICAgIGxldCB0eXBlYWJsZVF1ZXVlSXRlbXMgPSB0aGlzLnF1ZXVlLmdldFR5cGVhYmxlKCk7XG4gICAgbGV0IHJvdW5kcyA9ICgoKSA9PiB7XG4gICAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0eXBlYWJsZVF1ZXVlSXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtYmVyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudFN0ZXBzVG9TZWxlY3Rvcih7XG4gICAgICAgIHF1ZXVlSXRlbXM6IHR5cGVhYmxlUXVldWVJdGVtcyxcbiAgICAgICAgc2VsZWN0b3I6IG51bSxcbiAgICAgICAgY3Vyc29yUG9zaXRpb246IF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVyaXZlZEN1cnNvclBvc2l0aW9uLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0KSxcbiAgICAgICAgdG9cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcXVldWVBbmRSZXR1cm4sIHF1ZXVlQW5kUmV0dXJuX2ZuKS5jYWxsKHRoaXMsIFtcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzBdLFxuICAgICAgLi4uZHVwbGljYXRlKFxuICAgICAgICB7XG4gICAgICAgICAgZnVuYzogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9kZWxldGUsIGRlbGV0ZV9mbikuYmluZCh0aGlzKSxcbiAgICAgICAgICBkZWxheTogaW5zdGFudCA/IDAgOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFBhY2UsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgICAgZGVsZXRhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kc1xuICAgICAgKSxcbiAgICAgIGJvb2tFbmRRdWV1ZUl0ZW1zWzFdXG4gICAgXSwgYWN0aW9uT3B0cyk7XG4gIH1cbiAgZnJlZXplKCkge1xuICAgIHRoaXMuc3RhdHVzZXMuZnJvemVuID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmdvKClgLCBidXQgbW9yZS4uLiBcIm9mZiB0aGUgZ3JpZC5cIlxuICAgKlxuICAgKiAtIHdvbid0IHRyaWdnZXIgYGFmdGVyQ29tcGxldGVgIGNhbGxiYWNrXG4gICAqIC0gaXRlbXMgd29uJ3QgYmUgcmVwbGF5ZWQgYWZ0ZXIgYC5yZXNldCgpYFxuICAgKlxuICAgKiBXaGVuIGNhbGxlZCwgYWxsIG5vbi1kb25lIGl0ZW1zIHdpbGwgYmUgXCJmbHVzaGVkXCIgLS1cbiAgICogdGhhdCBpcywgZXhlY3V0ZWQsIGJ1dCBub3QgcmVtZW1iZXJlZC5cbiAgICovXG4gIGZsdXNoKGNiID0gKCkgPT4ge1xuICB9KSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9hdHRhY2hDdXJzb3IsIGF0dGFjaEN1cnNvcl9mbikuY2FsbCh0aGlzKTtcbiAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2ZpcmUsIGZpcmVfZm4pLmNhbGwodGhpcywgZmFsc2UpLnRoZW4oY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFF1ZXVlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cztcbiAgfVxuICB1cGRhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF91cGRhdGVPcHRpb25zLCB1cGRhdGVPcHRpb25zX2ZuKS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgfVxuICBlbXB0eShhY3Rpb25PcHRzID0ge30pIHtcbiAgICByZXR1cm4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF9xdWV1ZUFuZFJldHVybiwgcXVldWVBbmRSZXR1cm5fZm4pLmNhbGwodGhpcywgeyBmdW5jOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2VtcHR5LCBlbXB0eV9mbikuYmluZCh0aGlzKSB9LCBhY3Rpb25PcHRzKTtcbiAgfVxufSwgX2VtcHR5ID0gbmV3IFdlYWtTZXQoKSwgZW1wdHlfZm4gPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgaWYgKF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZWxlbWVudElzSW5wdXQsIGVsZW1lbnRJc0lucHV0X2ZuKS5jYWxsKHRoaXMpKSB7XG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgICByZXR1cm47XG4gIH1cbiAgX19wcml2YXRlR2V0KHRoaXMsIF9hbGxDaGFycywgYWxsQ2hhcnNfZ2V0KS5mb3JFYWNoKF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcmVtb3ZlTm9kZSwgcmVtb3ZlTm9kZV9mbikuYmluZCh0aGlzKSk7XG4gIHJldHVybjtcbn0sIF9maXJlID0gbmV3IFdlYWtTZXQoKSwgZmlyZV9mbiA9IGFzeW5jIGZ1bmN0aW9uKHJlbWVtYmVyID0gdHJ1ZSkge1xuICB0aGlzLnN0YXR1c2VzLnN0YXJ0ZWQgPSB0cnVlO1xuICBsZXQgY2xlYW5VcCA9IChxS2V5KSA9PiB7XG4gICAgdGhpcy5xdWV1ZS5kb25lKHFLZXksICFyZW1lbWJlcik7XG4gIH07XG4gIHRyeSB7XG4gICAgbGV0IHF1ZXVlSXRlbXMgPSBbLi4udGhpcy5xdWV1ZS5nZXRRdWV1ZSgpXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcXVldWVJdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBbcXVldWVLZXksIHF1ZXVlSXRlbV0gPSBxdWV1ZUl0ZW1zW2luZGV4XTtcbiAgICAgIGlmIChxdWV1ZUl0ZW0uZG9uZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIXF1ZXVlSXRlbS5kZWxldGFibGUgfHwgcXVldWVJdGVtLmRlbGV0YWJsZSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2FsbENoYXJzLCBhbGxDaGFyc19nZXQpLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV3SW5kZXggPSBhd2FpdCBfX3ByaXZhdGVNZXRob2QodGhpcywgX2ZpcmVJdGVtV2l0aENvbnRleHQsIGZpcmVJdGVtV2l0aENvbnRleHRfZm4pLmNhbGwodGhpcywgaW5kZXgsIHF1ZXVlSXRlbXMpO1xuICAgICAgICBBcnJheShuZXdJbmRleCAtIGluZGV4KS5maWxsKGluZGV4ICsgMSkubWFwKCh4LCB5KSA9PiB4ICsgeSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICAgIGxldCBba2V5XSA9IHF1ZXVlSXRlbXNbaV07XG4gICAgICAgICAgY2xlYW5VcChrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5kZXggPSBuZXdJbmRleDtcbiAgICAgIH1cbiAgICAgIGNsZWFuVXAocXVldWVLZXkpO1xuICAgIH1cbiAgICBpZiAoIXJlbWVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zdGF0dXNlcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgIGF3YWl0IHRoaXMub3B0cy5hZnRlckNvbXBsZXRlKHRoaXMpO1xuICAgIGlmICghdGhpcy5vcHRzLmxvb3ApIHtcbiAgICAgIHRocm93IFwiXCI7XG4gICAgfVxuICAgIGxldCBkZWxheSA9IHRoaXMub3B0cy5sb29wRGVsYXk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF93YWl0LCB3YWl0X2ZuKS5jYWxsKHRoaXMsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfcHJlcExvb3AsIHByZXBMb29wX2ZuKS5jYWxsKHRoaXMsIGRlbGF5WzBdKTtcbiAgICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZmlyZSwgZmlyZV9mbikuY2FsbCh0aGlzKTtcbiAgICB9LCBkZWxheVsxXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gdGhpcztcbn0sIF9tb3ZlID0gbmV3IFdlYWtTZXQoKSwgbW92ZV9mbiA9IGFzeW5jIGZ1bmN0aW9uKHN0ZXApIHtcbiAgdGhpcy5jdXJzb3JQb3NpdGlvbiA9IHVwZGF0ZUN1cnNvclBvc2l0aW9uKFxuICAgIHN0ZXAsXG4gICAgdGhpcy5jdXJzb3JQb3NpdGlvbixcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX2FsbENoYXJzLCBhbGxDaGFyc19nZXQpXG4gICk7XG4gIHJlcG9zaXRpb25DdXJzb3IodGhpcy5lbGVtZW50LCBfX3ByaXZhdGVHZXQodGhpcywgX2FsbENoYXJzLCBhbGxDaGFyc19nZXQpLCB0aGlzLmN1cnNvclBvc2l0aW9uKTtcbn0sIF9wcmVwTG9vcCA9IG5ldyBXZWFrU2V0KCksIHByZXBMb29wX2ZuID0gYXN5bmMgZnVuY3Rpb24oZGVsYXkpIHtcbiAgbGV0IGRlcml2ZWRDdXJzb3JQb3NpdGlvbiA9IF9fcHJpdmF0ZUdldCh0aGlzLCBfZGVyaXZlZEN1cnNvclBvc2l0aW9uLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0KTtcbiAgZGVyaXZlZEN1cnNvclBvc2l0aW9uICYmIGF3YWl0IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfbW92ZSwgbW92ZV9mbikuY2FsbCh0aGlzLCB7IHZhbHVlOiBkZXJpdmVkQ3Vyc29yUG9zaXRpb24gfSk7XG4gIGxldCBxdWV1ZUl0ZW1zID0gX19wcml2YXRlR2V0KHRoaXMsIF9hbGxDaGFycywgYWxsQ2hhcnNfZ2V0KS5tYXAoKGMpID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgU3ltYm9sKCksXG4gICAgICB7XG4gICAgICAgIGZ1bmM6IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZGVsZXRlLCBkZWxldGVfZm4pLmJpbmQodGhpcyksXG4gICAgICAgIGRlbGF5OiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFBhY2UsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgIGRlbGV0YWJsZTogdHJ1ZSxcbiAgICAgICAgc2hvdWxkUGF1c2VDdXJzb3I6ICgpID0+IHRydWVcbiAgICAgIH1cbiAgICBdO1xuICB9KTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlSXRlbXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgYXdhaXQgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9maXJlSXRlbVdpdGhDb250ZXh0LCBmaXJlSXRlbVdpdGhDb250ZXh0X2ZuKS5jYWxsKHRoaXMsIGluZGV4LCBxdWV1ZUl0ZW1zKTtcbiAgfVxuICB0aGlzLnF1ZXVlLnJlc2V0KCk7XG4gIHRoaXMucXVldWUuc2V0KDAsIHsgZGVsYXkgfSk7XG59LCBfZmlyZUl0ZW1XaXRoQ29udGV4dCA9IG5ldyBXZWFrU2V0KCksIGZpcmVJdGVtV2l0aENvbnRleHRfZm4gPSBmdW5jdGlvbihpbmRleCwgcXVldWVJdGVtcykge1xuICByZXR1cm4gZmlyZUl0ZW0oe1xuICAgIGluZGV4LFxuICAgIHF1ZXVlSXRlbXMsXG4gICAgd2FpdDogX19wcml2YXRlTWV0aG9kKHRoaXMsIF93YWl0LCB3YWl0X2ZuKS5iaW5kKHRoaXMpLFxuICAgIGN1cnNvcjogdGhpcy5jdXJzb3IsXG4gICAgY3Vyc29yT3B0aW9uczogdGhpcy5vcHRzLmN1cnNvclxuICB9KTtcbn0sIF93YWl0ID0gbmV3IFdlYWtTZXQoKSwgd2FpdF9mbiA9IGFzeW5jIGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgaWYgKHRoaXMuc3RhdHVzZXMuZnJvemVuKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMudW5mcmVlemUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhdHVzZXMuZnJvemVuID0gZmFsc2U7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgc2lsZW50IHx8IGF3YWl0IHRoaXMub3B0cy5iZWZvcmVTdGVwKHRoaXMpO1xuICBhd2FpdCB3YWl0KGNhbGxiYWNrLCBkZWxheSwgdGhpcy50aW1lb3V0cyk7XG4gIHNpbGVudCB8fCBhd2FpdCB0aGlzLm9wdHMuYWZ0ZXJTdGVwKHRoaXMpO1xufSwgX2F0dGFjaEN1cnNvciA9IG5ldyBXZWFrU2V0KCksIGF0dGFjaEN1cnNvcl9mbiA9IGFzeW5jIGZ1bmN0aW9uKCkge1xuICAhX19wcml2YXRlTWV0aG9kKHRoaXMsIF9lbGVtZW50SXNJbnB1dCwgZWxlbWVudElzSW5wdXRfZm4pLmNhbGwodGhpcykgJiYgdGhpcy5jdXJzb3IgJiYgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY3Vyc29yKTtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfc2hvdWxkUmVuZGVyQ3Vyc29yLCBzaG91bGRSZW5kZXJDdXJzb3JfZ2V0KSkge1xuICAgIHNldEN1cnNvclN0eWxlcyh0aGlzLmlkLCB0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuY3Vyc29yLmRhdGFzZXQudGlBbmltYXRpb25JZCA9IHRoaXMuaWQ7XG4gICAgbGV0IHsgYW5pbWF0aW9uIH0gPSB0aGlzLm9wdHMuY3Vyc29yO1xuICAgIGxldCB7IGZyYW1lcywgb3B0aW9ucyB9ID0gYW5pbWF0aW9uO1xuICAgIHNldEN1cnNvckFuaW1hdGlvbih7XG4gICAgICBmcmFtZXMsXG4gICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRzLmN1cnNvclNwZWVkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0sIF9lbGVtZW50SXNJbnB1dCA9IG5ldyBXZWFrU2V0KCksIGVsZW1lbnRJc0lucHV0X2ZuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpc0lucHV0KHRoaXMuZWxlbWVudCk7XG59LCBfcXVldWVBbmRSZXR1cm4gPSBuZXcgV2Vha1NldCgpLCBxdWV1ZUFuZFJldHVybl9mbiA9IGZ1bmN0aW9uKHN0ZXBzLCBvcHRzKSB7XG4gIHRoaXMucXVldWUuYWRkKHN0ZXBzKTtcbiAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9tYXliZUFwcGVuZFBhdXNlLCBtYXliZUFwcGVuZFBhdXNlX2ZuKS5jYWxsKHRoaXMsIG9wdHMpO1xuICByZXR1cm4gdGhpcztcbn0sIF9tYXliZUFwcGVuZFBhdXNlID0gbmV3IFdlYWtTZXQoKSwgbWF5YmVBcHBlbmRQYXVzZV9mbiA9IGZ1bmN0aW9uKG9wdHMgPSB7fSkge1xuICBsZXQgZGVsYXkgPSBvcHRzLmRlbGF5O1xuICBkZWxheSAmJiB0aGlzLnF1ZXVlLmFkZCh7IGRlbGF5IH0pO1xufSwgX2dlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtcyA9IG5ldyBXZWFrU2V0KCksIGdlbmVyYXRlVGVtcG9yYXJ5T3B0aW9uUXVldWVJdGVtc19mbiA9IGZ1bmN0aW9uKG5ld09wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gW1xuICAgIHsgZnVuYzogKCkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF91cGRhdGVPcHRpb25zLCB1cGRhdGVPcHRpb25zX2ZuKS5jYWxsKHRoaXMsIG5ld09wdGlvbnMpIH0sXG4gICAgeyBmdW5jOiAoKSA9PiBfX3ByaXZhdGVNZXRob2QodGhpcywgX3VwZGF0ZU9wdGlvbnMsIHVwZGF0ZU9wdGlvbnNfZm4pLmNhbGwodGhpcywgdGhpcy5vcHRzKSB9XG4gIF07XG59LCBfdXBkYXRlT3B0aW9ucyA9IG5ldyBXZWFrU2V0KCksIHVwZGF0ZU9wdGlvbnNfZm4gPSBhc3luYyBmdW5jdGlvbihvcHRzKSB7XG4gIHRoaXMub3B0cyA9IG1lcmdlKHRoaXMub3B0cywgb3B0cyk7XG59LCBfZ2VuZXJhdGVRdWV1ZSA9IG5ldyBXZWFrU2V0KCksIGdlbmVyYXRlUXVldWVfZm4gPSBmdW5jdGlvbigpIHtcbiAgbGV0IHN0cmluZ3MgPSB0aGlzLm9wdHMuc3RyaW5ncy5maWx0ZXIoKHN0cmluZykgPT4gISFzdHJpbmcpO1xuICBzdHJpbmdzLmZvckVhY2goKHN0cmluZywgaW5kZXgpID0+IHtcbiAgICB0aGlzLnR5cGUoc3RyaW5nKTtcbiAgICBpZiAoaW5kZXggKyAxID09PSBzdHJpbmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3BsaXRJdGVtcyA9IHRoaXMub3B0cy5icmVha0xpbmVzID8gW3sgZnVuYzogKCkgPT4gX19wcml2YXRlTWV0aG9kKHRoaXMsIF90eXBlLCB0eXBlX2ZuKS5jYWxsKHRoaXMsIGNyZWF0ZUVsZW1lbnQoXCJCUlwiKSksIHR5cGVhYmxlOiB0cnVlIH1dIDogZHVwbGljYXRlKFxuICAgICAge1xuICAgICAgICBmdW5jOiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2RlbGV0ZSwgZGVsZXRlX2ZuKS5iaW5kKHRoaXMpLFxuICAgICAgICBkZWxheTogX19wcml2YXRlTWV0aG9kKHRoaXMsIF9nZXRQYWNlLCBnZXRQYWNlX2ZuKS5jYWxsKHRoaXMsIDEpXG4gICAgICB9LFxuICAgICAgdGhpcy5xdWV1ZS5nZXRUeXBlYWJsZSgpLmxlbmd0aFxuICAgICk7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9hZGRTcGxpdFBhdXNlLCBhZGRTcGxpdFBhdXNlX2ZuKS5jYWxsKHRoaXMsIHNwbGl0SXRlbXMpO1xuICB9KTtcbn0sIF9idWlsZE9wdGlvbnMgPSBuZXcgV2Vha01hcCgpLCBfcHJlcGVuZEhhcmRjb2RlZFN0cmluZ3MgPSBuZXcgV2Vha1NldCgpLCBwcmVwZW5kSGFyZGNvZGVkU3RyaW5nc19mbiA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgbGV0IGV4aXN0aW5nTWFya3VwID0gdGhpcy5lbGVtZW50LmlubmVySFRNTDtcbiAgaWYgKCFleGlzdGluZ01hcmt1cCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG4gIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICBpZiAodGhpcy5vcHRzLnN0YXJ0RGVsZXRlKSB7XG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IGV4aXN0aW5nTWFya3VwO1xuICAgIGV4cGFuZFRleHROb2Rlcyh0aGlzLmVsZW1lbnQpO1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfYWRkU3BsaXRQYXVzZSwgYWRkU3BsaXRQYXVzZV9mbikuY2FsbCh0aGlzLCBkdXBsaWNhdGUoXG4gICAgICB7XG4gICAgICAgIGZ1bmM6IF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfZGVsZXRlLCBkZWxldGVfZm4pLmJpbmQodGhpcyksXG4gICAgICAgIGRlbGF5OiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2dldFBhY2UsIGdldFBhY2VfZm4pLmNhbGwodGhpcywgMSksXG4gICAgICAgIGRlbGV0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWxsQ2hhcnMsIGFsbENoYXJzX2dldCkubGVuZ3RoXG4gICAgKSk7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cbiAgcmV0dXJuIHNwbGl0T25CcmVhayhleGlzdGluZ01hcmt1cCkuY29uY2F0KHN0cmluZ3MpO1xufSwgX3NldFVwQ3Vyc29yID0gbmV3IFdlYWtTZXQoKSwgc2V0VXBDdXJzb3JfZm4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfaXNJbnB1dCwgaXNJbnB1dF9nZXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGN1cnNvciA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBjdXJzb3IuY2xhc3NOYW1lID0gQ1VSU09SX0NMQVNTO1xuICBpZiAoIV9fcHJpdmF0ZUdldCh0aGlzLCBfc2hvdWxkUmVuZGVyQ3Vyc29yLCBzaG91bGRSZW5kZXJDdXJzb3JfZ2V0KSkge1xuICAgIGN1cnNvci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICByZXR1cm4gY3Vyc29yO1xuICB9XG4gIGN1cnNvci5pbm5lckhUTUwgPSBnZXRQYXJzZWRCb2R5KHRoaXMub3B0cy5jdXJzb3JDaGFyKS5pbm5lckhUTUw7XG4gIHJldHVybiBjdXJzb3I7XG59LCBfYWRkU3BsaXRQYXVzZSA9IG5ldyBXZWFrU2V0KCksIGFkZFNwbGl0UGF1c2VfZm4gPSBmdW5jdGlvbihpdGVtcykge1xuICBsZXQgZGVsYXkgPSB0aGlzLm9wdHMubmV4dFN0cmluZ0RlbGF5O1xuICB0aGlzLnF1ZXVlLmFkZChbeyBkZWxheTogZGVsYXlbMF0gfSwgLi4uaXRlbXMsIHsgZGVsYXk6IGRlbGF5WzFdIH1dKTtcbn0sIF90eXBlID0gbmV3IFdlYWtTZXQoKSwgdHlwZV9mbiA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgaW5zZXJ0SW50b0VsZW1lbnQodGhpcy5lbGVtZW50LCBjaGFyKTtcbn0sIF9kZWxldGUgPSBuZXcgV2Vha1NldCgpLCBkZWxldGVfZm4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFfX3ByaXZhdGVHZXQodGhpcywgX2FsbENoYXJzLCBhbGxDaGFyc19nZXQpLmxlbmd0aClcbiAgICByZXR1cm47XG4gIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2lzSW5wdXQsIGlzSW5wdXRfZ2V0KSkge1xuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZS5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgX19wcml2YXRlTWV0aG9kKHRoaXMsIF9yZW1vdmVOb2RlLCByZW1vdmVOb2RlX2ZuKS5jYWxsKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfYWxsQ2hhcnMsIGFsbENoYXJzX2dldClbdGhpcy5jdXJzb3JQb3NpdGlvbl0pO1xuICB9XG59LCBfcmVtb3ZlTm9kZSA9IG5ldyBXZWFrU2V0KCksIHJlbW92ZU5vZGVfZm4gPSBmdW5jdGlvbihub2RlKSB7XG4gIHJlbW92ZU5vZGUobm9kZSwgdGhpcy5lbGVtZW50KTtcbn0sIF9nZXRQYWNlID0gbmV3IFdlYWtTZXQoKSwgZ2V0UGFjZV9mbiA9IGZ1bmN0aW9uKGluZGV4ID0gMCkge1xuICByZXR1cm4gY2FsY3VsYXRlUGFjZSh0aGlzLm9wdHMpW2luZGV4XTtcbn0sIF9kZXJpdmVkQ3Vyc29yUG9zaXRpb24gPSBuZXcgV2Vha1NldCgpLCBkZXJpdmVkQ3Vyc29yUG9zaXRpb25fZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnByZWRpY3RlZEN1cnNvclBvc2l0aW9uID8/IHRoaXMuY3Vyc29yUG9zaXRpb247XG59LCBfaXNJbnB1dCA9IG5ldyBXZWFrU2V0KCksIGlzSW5wdXRfZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpc0lucHV0KHRoaXMuZWxlbWVudCk7XG59LCBfc2hvdWxkUmVuZGVyQ3Vyc29yID0gbmV3IFdlYWtTZXQoKSwgc2hvdWxkUmVuZGVyQ3Vyc29yX2dldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLm9wdHMuY3Vyc29yICYmICFfX3ByaXZhdGVHZXQodGhpcywgX2lzSW5wdXQsIGlzSW5wdXRfZ2V0KTtcbn0sIF9hbGxDaGFycyA9IG5ldyBXZWFrU2V0KCksIGFsbENoYXJzX2dldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2V0QWxsQ2hhcnModGhpcy5lbGVtZW50KTtcbn0sIF9hKTtcbmNvbnN0IER5bmFtaWNFbGVtZW50Q29tcG9uZW50ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCB7IGFzOiBBcyB9ID0gcHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChBcywgeyByZWYsIC4uLnByb3BzIH0pO1xufSk7XG5jb25zdCBkZWZhdWx0UHJvcE9wdGlvbnMgPSB7fTtcbmNvbnN0IFR5cGVJdCA9ICh7XG4gIGFzID0gXCJzcGFuXCIsXG4gIG9wdGlvbnMgPSBkZWZhdWx0UHJvcE9wdGlvbnMsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgZ2V0QmVmb3JlSW5pdCA9IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UsXG4gIGdldEFmdGVySW5pdCA9IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UsXG4gIC4uLnJlbWFpbmluZ1Byb3BzXG59KSA9PiB7XG4gIGNvbnN0IGVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluc3RhbmNlUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbc2hvdWxkU2hvd0NoaWxkcmVuLCBzZXRTaG91bGRTaG93Q2hpbGRyZW5dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpbnN0YW5jZU9wdGlvbnMsIHNldEluc3RhbmNlT3B0aW9uc10gPSB1c2VTdGF0ZShudWxsKTtcbiAgZnVuY3Rpb24gY2FsY3VsYXRlT3B0aW9ucygpIHtcbiAgICBjb25zdCBvcHRpb25zQ2xvbmUgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAoY2hpbGRyZW4gJiYgZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICBvcHRpb25zQ2xvbmUuc3RyaW5ncyA9IGVsZW1lbnRSZWYuY3VycmVudC5pbm5lckhUTUw7XG4gICAgfVxuICAgIHNldEluc3RhbmNlT3B0aW9ucyhvcHRpb25zQ2xvbmUpO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlTmV3SW5zdGFuY2UoKSB7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IG5ldyBUeXBlSXQkMShlbGVtZW50UmVmLmN1cnJlbnQsIGluc3RhbmNlT3B0aW9ucyk7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudCA9IGdldEJlZm9yZUluaXQoaW5zdGFuY2VSZWYuY3VycmVudCk7XG4gICAgaW5zdGFuY2VSZWYuY3VycmVudC5nbygpO1xuICAgIGluc3RhbmNlUmVmLmN1cnJlbnQgPSBnZXRBZnRlckluaXQoaW5zdGFuY2VSZWYuY3VycmVudCk7XG4gIH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxjdWxhdGVPcHRpb25zKCk7XG4gICAgc2V0U2hvdWxkU2hvd0NoaWxkcmVuKGZhbHNlKTtcbiAgfSwgW29wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2EyO1xuICAgIGlmICghaW5zdGFuY2VPcHRpb25zKVxuICAgICAgcmV0dXJuO1xuICAgICgoX2EyID0gaW5zdGFuY2VSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi51cGRhdGVPcHRpb25zKGluc3RhbmNlT3B0aW9ucykpIHx8IGdlbmVyYXRlTmV3SW5zdGFuY2UoKTtcbiAgfSwgW2luc3RhbmNlT3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSBpbnN0YW5jZVJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmRlc3Ryb3koKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBEeW5hbWljRWxlbWVudENvbXBvbmVudCxcbiAgICB7XG4gICAgICByZWY6IGVsZW1lbnRSZWYsXG4gICAgICBhcyxcbiAgICAgIGNoaWxkcmVuOiBzaG91bGRTaG93Q2hpbGRyZW4gPyBjaGlsZHJlbiA6IG51bGwsXG4gICAgICBzdHlsZTogeyBvcGFjaXR5OiBzaG91bGRTaG93Q2hpbGRyZW4gPyAwIDogMSB9LFxuICAgICAgLi4ucmVtYWluaW5nUHJvcHNcbiAgICB9XG4gICk7XG59O1xuZXhwb3J0IHtcbiAgVHlwZUl0IGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typeit-react/dist/index.es.js\n");

/***/ })

};
;